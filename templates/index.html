{% extends "base.html" %}
{% import "macros/pillar_cards.html" as cards %}

{% block title %}{{ section.extra.hero_title | default(value=config.title) }}{% endblock %}

{% block head_extra %}
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js" defer></script>
{% endblock %}

{% block content %}

{# ===== Hero — brandmark ===== #}
<section class="hero" aria-label="Hero">
  <canvas class="hero__mesh" id="hero-mesh" aria-hidden="true"></canvas>
  <div class="hero__display">
    <h1 class="hero__big">
      {% if lang == "fr" %}Le Futur{% elif lang == "it" %}Il Futuro{% elif lang == "en" %}The Future{% else %}Die Zukunft{% endif %}
    </h1>
  </div>
</section>

{# ===== Subtitle / positioning ===== #}
<section class="canvas" aria-label="Subtitle">
  <div class="container container--narrow" style="text-align: center;">
    <h2>{{ section.extra.hero_subtitle | default(value="") }}</h2>
  </div>
</section>

{# ===== What's changing ===== #}
{% if section.extra.changes %}
<section class="canvas" aria-label="{{ section.extra.changes_title | default(value='What is changing') }}">
  <div class="container">
    <h2 style="text-align: center; margin-bottom: 2rem;">{{ section.extra.changes_title | default(value="") }}</h2>
    <div class="bento-grid">
      {% for item in section.extra.changes %}
      <div class="glass-card reveal-up reveal-delay-{{ loop.index }}">
        {% if item.icon %}<p class="glass-card__icon">{{ item.icon }}</p>{% endif %}
        <p class="glass-card__title">{{ item.title }}</p>
        <p class="glass-card__text">{{ item.text }}</p>
      </div>
      {% endfor %}
    </div>
  </div>
</section>
{% endif %}

{# ===== What we propose (pillars) ===== #}
{% if section.extra.pillars %}
<section class="canvas" aria-label="{{ section.extra.pillars_title | default(value='Pillars') }}">
  <div class="container">
    <h2 style="text-align: center; margin-bottom: 2rem;">{{ section.extra.pillars_title | default(value="") }}</h2>
    {{ cards::render(pillars=section.extra.pillars) }}
  </div>
</section>
{% endif %}

{# ===== How we start (timeline) ===== #}
{% if section.extra.timeline %}
<section class="canvas" aria-label="{{ section.extra.timeline_title | default(value='Timeline') }}">
  <div class="container" style="display: flex; flex-direction: column; align-items: center;">
    <h2 style="text-align: center; margin-bottom: 2rem;">{{ section.extra.timeline_title | default(value="") }}</h2>
    <div class="timeline">
      {% for step in section.extra.timeline %}
      <div class="timeline__item reveal-up reveal-delay-{{ loop.index }}">
        <div class="timeline__marker">{{ loop.index }}</div>
        <div class="timeline__content">
          <p class="timeline__phase">{{ step.phase }}</p>
          <p class="timeline__title">{{ step.title }}</p>
          <p class="timeline__text">{{ step.text }}</p>
        </div>
      </div>
      {% endfor %}
    </div>
  </div>
</section>
{% endif %}

{# ===== CTA — get involved ===== #}
{% if section.extra.cta_title %}
<section class="canvas cta-section" aria-label="{{ section.extra.cta_title }}">
  <div class="container container--narrow" style="text-align: center;">
    <h2>{{ section.extra.cta_title }}</h2>
    {% if section.extra.cta_text %}
    <p class="cta-section__text">{{ section.extra.cta_text }}</p>
    {% endif %}
    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
      <a class="btn btn--glow" href="{{ get_url(path='@/mitmachen.md', lang=lang) }}">{{ trans(key="cta_join", lang=lang) }}</a>
      <a class="btn btn--outline" href="{{ get_url(path='@/programm.md', lang=lang) }}">{{ trans(key="cta_program", lang=lang) }}</a>
    </div>
  </div>
</section>
{% endif %}

<script>
(function() {
  var canvas = document.getElementById('hero-mesh');
  if (!canvas) return;

  function init() {
    if (typeof THREE === 'undefined') return;
    var hero = canvas.parentElement;
    var w = hero.offsetWidth;
    var h = hero.offsetHeight;
    var dpr = Math.min(window.devicePixelRatio || 1, 2);

    // Renderer
    var renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      alpha: true,
      antialias: true
    });
    renderer.setSize(w, h);
    renderer.setPixelRatio(dpr);

    // Scene & camera
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(35, w / h, 0.1, 100);
    camera.position.z = 22;

    // Build Swiss cross positions (3D cross visible from all axes)
    var positions = [];
    var seen = {};

    function add(x, y, z) {
      var key = x + ',' + y + ',' + z;
      if (!seen[key]) {
        seen[key] = true;
        positions.push([x, y, z]);
      }
    }

    // Bar along X axis
    for (var x = -3; x <= 3; x++)
      for (var y = -1; y <= 1; y++)
        for (var z = -1; z <= 1; z++)
          add(x, y, z);

    // Bar along Y axis
    for (var x = -1; x <= 1; x++)
      for (var y = -3; y <= 3; y++)
        for (var z = -1; z <= 1; z++)
          add(x, y, z);

    // Bar along Z axis
    for (var x = -1; x <= 1; x++)
      for (var y = -1; y <= 1; y++)
        for (var z = -3; z <= 3; z++)
          add(x, y, z);

    // Create instanced mesh — cube edges
    var cubeSize = 0.88;
    var boxGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    var edgesGeo = new THREE.EdgesGeometry(boxGeo);

    // Determine color based on theme
    var isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    var edgeColor = isDark ? 0x7c3aed : 0xa855f7;
    var edgeOpacity = isDark ? 0.25 : 0.18;

    var lineMat = new THREE.LineBasicMaterial({
      color: edgeColor,
      transparent: true,
      opacity: edgeOpacity
    });

    var group = new THREE.Group();

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];
      var line = new THREE.LineSegments(edgesGeo, lineMat);
      line.position.set(p[0], p[1], p[2]);
      group.add(line);
    }

    scene.add(group);

    // Initial tilt
    group.rotation.x = 0.4;
    group.rotation.y = 0.6;

    // Animation loop
    var raf;
    function animate() {
      raf = requestAnimationFrame(animate);
      group.rotation.y += 0.002;
      group.rotation.x += 0.0005;
      renderer.render(scene, camera);
    }
    animate();

    // Resize handler
    function onResize() {
      w = hero.offsetWidth;
      h = hero.offsetHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    // Theme change observer
    var observer = new MutationObserver(function() {
      var dark = document.documentElement.getAttribute('data-theme') === 'dark';
      lineMat.color.setHex(dark ? 0x7c3aed : 0xa855f7);
      lineMat.opacity = dark ? 0.25 : 0.18;
    });
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // Pause when not visible
    var paused = false;
    var io = new IntersectionObserver(function(entries) {
      if (entries[0].isIntersecting) {
        if (paused) { paused = false; animate(); }
      } else {
        paused = true;
        cancelAnimationFrame(raf);
      }
    }, { threshold: 0 });
    io.observe(hero);
  }

  // Wait for Three.js to load
  if (typeof THREE !== 'undefined') {
    init();
  } else {
    var script = document.querySelector('script[src*="three"]');
    if (script) script.addEventListener('load', init);
  }
})();

// Reveal-on-scroll
(function() {
  var els = document.querySelectorAll('.reveal-up');
  if (!els.length) return;
  var io = new IntersectionObserver(function(entries) {
    entries.forEach(function(e) {
      if (e.isIntersecting) {
        e.target.classList.add('is-visible');
        io.unobserve(e.target);
      }
    });
  }, { threshold: 0.15 });
  els.forEach(function(el) { io.observe(el); });
})();
</script>

{% endblock %}
